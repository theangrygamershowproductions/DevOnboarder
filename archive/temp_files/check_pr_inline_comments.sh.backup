#!/bin/bash

# DevOnboarder PR Inline Comments Checker
# Efficiently extracts and displays Copilot and reviewer inline comments

set -euo pipefail

show_usage() {
    cat << 'EOF'
DevOnboarder PR Inline Comments Checker with Resolution Tracking

Usage: check_pr_inline_comments.sh [OPTIONS] PR_NUMBER

DISPLAY OPTIONS:
    --summary           Show summary of comments only
    --copilot-only      Show only Copilot comments
    --suggestions       Show only comments with code suggestions
    --format=json       Output raw JSON format
    --open-browser      Open all comment URLs in browser

RESOLUTION TRACKING:
    --annotate          Interactive mode to add resolution notes
    --resolution-summary Show resolutions and reasoning for comments
    --learning-export   Export resolution patterns for documentation
    --verify-resolutions Check that all comments have resolutions

EXAMPLES:
    # Basic usage
    ./scripts/check_pr_inline_comments.sh 1330
    ./scripts/check_pr_inline_comments.sh --copilot-only 1330
    ./scripts/check_pr_inline_comments.sh --summary 1330

    # Resolution tracking
    ./scripts/check_pr_inline_comments.sh --annotate 1330
    ./scripts/check_pr_inline_comments.sh --resolution-summary 1330
    ./scripts/check_pr_inline_comments.sh --learning-export 1330

ENVIRONMENT:
    Requires GitHub CLI (gh) with proper authentication
    Resolution data stored in .devonboarder/pr_resolutions/
EOF
}

# Parse command line arguments
SUMMARY_ONLY=false
COPILOT_ONLY=false
SUGGESTIONS_ONLY=false
OUTPUT_FORMAT="human"
OPEN_BROWSER=false
ANNOTATE_MODE=false
RESOLUTION_SUMMARY=false
LEARNING_EXPORT=false
VERIFY_RESOLUTIONS=false
PR_NUMBER=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --summary)
            SUMMARY_ONLY=true
            shift
            ;;
        --copilot-only)
            COPILOT_ONLY=true
            shift
            ;;
        --suggestions)
            SUGGESTIONS_ONLY=true
            shift
            ;;
        --format=*)
            OUTPUT_FORMAT="${1#*=}"
            shift
            ;;
        --open-browser)
            OPEN_BROWSER=true
            shift
            ;;
        --annotate)
            ANNOTATE_MODE=true
            shift
            ;;
        --resolution-summary)
            RESOLUTION_SUMMARY=true
            shift
            ;;
        --learning-export)
            LEARNING_EXPORT=true
            shift
            ;;
        --verify-resolutions)
            VERIFY_RESOLUTIONS=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            if [[ -z "$PR_NUMBER" ]]; then
                PR_NUMBER="$1"
            else
                echo "Error: Unknown option $1"
                show_usage
                exit 1
            fi
            shift
            ;;
    esac
done

if [[ -z "$PR_NUMBER" ]]; then
    echo "Error: PR number is required"
    show_usage
    exit 1
fi

# Validate PR number is numeric
if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
    echo "Error: PR number must be numeric"
    exit 1
fi

# Get repository information
REPO_INFO=$(gh repo view --json owner,name)
OWNER=$(echo "$REPO_INFO" | jq -r '.owner.login')
REPO=$(echo "$REPO_INFO" | jq -r '.name')

# Resolution data management
RESOLUTION_DIR=".devonboarder/pr_resolutions"
RESOLUTION_FILE="$RESOLUTION_DIR/$PR_NUMBER.yaml"

# Ensure resolution directory exists
mkdir -p "$RESOLUTION_DIR"

# Resolution management functions
load_resolutions() {
    if [[ -f "$RESOLUTION_FILE" ]]; then
        cat "$RESOLUTION_FILE"
    else
        echo "# Resolution annotations for PR #$PR_NUMBER"
        echo "# Generated by DevOnboarder PR Comments Tool"
        echo "# Format: comment_ID: {resolution_action, reasoning, commit_hash, additional_notes}"
        echo ""
    fi
}

save_resolution() {
    local comment_id="$1"
    local resolution_action="$2"
    local reasoning="$3"
    local additional_notes="$4"
    local commit_hash="${5:-}"

    # Create or update resolution file
    {
        load_resolutions | grep -v "^comment_$comment_id:" || true
        printf "comment_%s:\n" "$comment_id"
        printf "  resolution_action: \"%s\"\n" "$resolution_action"
        printf "  reasoning: \"%s\"\n" "$reasoning"
        printf "  additional_notes: \"%s\"\n" "$additional_notes"
        if [[ -n "$commit_hash" ]]; then
            printf "  commit_hash: \"%s\"\n" "$commit_hash"
        fi
        printf "  timestamp: \"%s\"\n" "$(date -Iseconds)"
        printf "\n"
    } > "$RESOLUTION_FILE"
}

get_resolution() {
    local comment_id="$1"
    if [[ -f "$RESOLUTION_FILE" ]]; then
        grep -A 10 "^comment_$comment_id:" "$RESOLUTION_FILE" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Fetch inline comments
COMMENTS_JSON=$(gh api "/repos/$OWNER/$REPO/pulls/$PR_NUMBER/comments" 2>/dev/null || {
    echo "Error: Failed to fetch comments for PR #$PR_NUMBER"
    echo "Make sure the PR exists and you have proper access"
    exit 1
})

# Check if no comments found
COMMENT_COUNT=$(echo "$COMMENTS_JSON" | jq length)

# Output raw JSON if requested (no headers)
if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    echo "$COMMENTS_JSON"
    exit 0
fi

# For human output, show headers
echo "Fetching inline comments for PR #$PR_NUMBER..."
echo "Repository: $OWNER/$REPO"
echo ""

if [[ "$COMMENT_COUNT" -eq 0 ]]; then
    echo "No inline comments found for PR #$PR_NUMBER"
    exit 0
fi

# Route to specific modes
if [[ "$ANNOTATE_MODE" == "true" ]]; then
    annotate_resolutions
    exit 0
elif [[ "$RESOLUTION_SUMMARY" == "true" ]]; then
    show_resolution_summary
    exit 0
elif [[ "$LEARNING_EXPORT" == "true" ]]; then
    export_learning_patterns
    exit 0
elif [[ "$VERIFY_RESOLUTIONS" == "true" ]]; then
    verify_resolutions
    exit 0
fi

# Filter comments based on options
FILTERED_COMMENTS="$COMMENTS_JSON"

if [[ "$COPILOT_ONLY" == true ]]; then
    FILTERED_COMMENTS=$(echo "$FILTERED_COMMENTS" | jq '[.[] | select(.user.login == "Copilot" or .user.login == "copilot-pull-request-reviewer[bot]")]')
fi

if [[ "$SUGGESTIONS_ONLY" == true ]]; then
    FILTERED_COMMENTS=$(echo "$FILTERED_COMMENTS" | jq '[.[] | select(.body | contains("```suggestion"))]')
fi

FILTERED_COUNT=$(echo "$FILTERED_COMMENTS" | jq length)

# Summary mode
if [[ "$SUMMARY_ONLY" == true ]]; then
    echo "📊 INLINE COMMENTS SUMMARY"
    echo "=========================="
    echo "Total comments: $COMMENT_COUNT"
    echo "Filtered comments: $FILTERED_COUNT"
    echo ""

    # Group by file
    echo "📁 COMMENTS BY FILE:"
    echo "$FILTERED_COMMENTS" | jq -r '.[] | .path' | sort | uniq -c | sort -nr | while read -r count file; do
        printf "  %2d  %s\n" "$count" "$file"
    done
    echo ""

    # Group by user
    echo "👤 COMMENTS BY USER:"
    echo "$FILTERED_COMMENTS" | jq -r '.[] | .user.login' | sort | uniq -c | sort -nr | while read -r count user; do
        printf "  %2d  %s\n" "$count" "$user"
    done
    echo ""

    # Show suggestions count
    SUGGESTIONS_COUNT=$(echo "$FILTERED_COMMENTS" | jq '[.[] | select(.body | contains("```suggestion"))] | length')
    echo "💡 Code suggestions: $SUGGESTIONS_COUNT"

    exit 0
fi

# Open URLs in browser if requested
if [[ "$OPEN_BROWSER" == true ]]; then
    echo "Opening comment URLs in browser..."
    echo "$FILTERED_COMMENTS" | jq -r '.[].html_url' | while read -r url; do
        if command -v xdg-open >/dev/null 2>&1; then
            xdg-open "$url" 2>/dev/null &
        elif command -v open >/dev/null 2>&1; then
            open "$url" 2>/dev/null &
        else
            echo "Browser opening not supported on this system"
            echo "URL: $url"
        fi
    done
    exit 0
fi

# Full output mode
echo "📋 INLINE COMMENTS DETAILS"
echo "=========================="
echo "Showing $FILTERED_COUNT of $COMMENT_COUNT total comments"
echo ""

# Process each comment
echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment; do
    # Extract comment details
    COMMENT_ID=$(echo "$comment" | jq -r '.id')
    USER=$(echo "$comment" | jq -r '.user.login')
    CREATED_AT=$(echo "$comment" | jq -r '.created_at')
    FILE_PATH=$(echo "$comment" | jq -r '.path')
    LINE_NUMBER=$(echo "$comment" | jq -r '.line')
    BODY=$(echo "$comment" | jq -r '.body')
    HTML_URL=$(echo "$comment" | jq -r '.html_url')

    # Format timestamp
    FORMATTED_DATE=$(date -d "$CREATED_AT" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "$CREATED_AT")

    echo "┌─────────────────────────────────────────────────────────────"
    echo "│ 💬 Comment ID: $COMMENT_ID"
    echo "│ 👤 User: $USER"
    echo "│ 📅 Date: $FORMATTED_DATE"
    echo "│ 📁 File: $FILE_PATH"
    echo "│ 📍 Line: $LINE_NUMBER"
    echo "│ 🔗 URL: $HTML_URL"
    echo "├─────────────────────────────────────────────────────────────"

    # Format comment body with proper indentation
    echo "│ 🤖 Comment:"
    while IFS= read -r line; do
        echo "│ $line"
    done <<< "$BODY"

    # Check for and display resolution
    RESOLUTION=$(get_resolution "$COMMENT_ID")
    if [[ -n "$RESOLUTION" ]]; then
        echo "│"
        echo "│ ✅ RESOLUTION:"
        echo "$RESOLUTION" | grep -E "(resolution_action|reasoning|additional_notes|commit_hash)" | while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*\"(.*)\"$ ]]; then
                KEY="${BASH_REMATCH[1]}"
                VALUE="${BASH_REMATCH[2]}"
                case "$KEY" in
                    "resolution_action") echo "│   ⚡ Action: $VALUE" ;;
                    "reasoning") echo "│   💡 Reason: $VALUE" ;;
                    "additional_notes") [[ -n "$VALUE" ]] && echo "│   📝 Notes: $VALUE" ;;
                    "commit_hash") [[ -n "$VALUE" ]] && echo "│   🔗 Commit: $VALUE" ;;
                esac
            fi
        done
    fi

    echo "└─────────────────────────────────────────────────────────────"
    echo ""
done

echo "✅ Complete! Found $FILTERED_COUNT relevant inline comments."

# Show quick action suggestions
if [[ "$FILTERED_COUNT" -gt 0 ]]; then
    echo ""
    echo "🚀 QUICK ACTIONS:"
    echo "  View in browser:  ./scripts/check_pr_inline_comments.sh --open-browser $PR_NUMBER"
    echo "  Summary only:     ./scripts/check_pr_inline_comments.sh --summary $PR_NUMBER"
    echo "  Copilot only:     ./scripts/check_pr_inline_comments.sh --copilot-only $PR_NUMBER"
    echo "  Suggestions only: ./scripts/check_pr_inline_comments.sh --suggestions $PR_NUMBER"
    echo "  Add resolutions:  ./scripts/check_pr_inline_comments.sh --annotate $PR_NUMBER"
    echo "  View resolutions: ./scripts/check_pr_inline_comments.sh --resolution-summary $PR_NUMBER"
fi

# Resolution tracking functions
annotate_resolutions() {
    echo "🎯 RESOLUTION ANNOTATION MODE"
    echo "Adding resolution notes for PR #$PR_NUMBER comments"
    echo ""

    # Process each comment for annotation
    echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment; do
        COMMENT_ID=$(echo "$comment" | jq -r '.id')
        USER=$(echo "$comment" | jq -r '.user.login')
        FILE_PATH=$(echo "$comment" | jq -r '.path')
        LINE_NUMBER=$(echo "$comment" | jq -r '.line')
        BODY=$(echo "$comment" | jq -r '.body')

        # Check if resolution already exists
        EXISTING_RESOLUTION=$(get_resolution "$COMMENT_ID")

        echo "┌─────────────────────────────────────────────────────────────"
        echo "│ 💬 Comment ID: $COMMENT_ID"
        echo "│ 👤 User: $USER"
        echo "│ 📁 File: $FILE_PATH:$LINE_NUMBER"
        echo "├─────────────────────────────────────────────────────────────"
        echo "│ Comment:"
        while IFS= read -r line; do
            echo "│ $line"
        done <<< "$BODY"
        echo "└─────────────────────────────────────────────────────────────"

        if [[ -n "$EXISTING_RESOLUTION" ]]; then
            echo "⚠️  Resolution already exists:"
            echo "$EXISTING_RESOLUTION" | grep -E "(resolution_action|reasoning)" | sed 's/^/   /'
            echo ""
            read -rp "Update existing resolution? (y/N): " UPDATE_CHOICE
            if [[ "$UPDATE_CHOICE" != "y" && "$UPDATE_CHOICE" != "Y" ]]; then
                echo "Skipping..."
                echo ""
                continue
            fi
        fi

        echo ""
        echo "📝 Add resolution for this comment:"
        read -rp "Resolution action: " RESOLUTION_ACTION
        read -rp "Reasoning: " REASONING
        read -rp "Additional notes (optional): " ADDITIONAL_NOTES
        read -rp "Commit hash (optional): " COMMIT_HASH

        if [[ -n "$RESOLUTION_ACTION" ]]; then
            save_resolution "$COMMENT_ID" "$RESOLUTION_ACTION" "$REASONING" "$ADDITIONAL_NOTES" "$COMMIT_HASH"
            echo "✅ Resolution saved!"
        else
            echo "❌ Skipped - no resolution action provided"
        fi
        echo ""
    done

    echo "🎯 Resolution annotation complete!"
    echo "View resolutions: ./scripts/check_pr_inline_comments.sh --resolution-summary $PR_NUMBER"
}

show_resolution_summary() {
    echo "📋 RESOLUTION SUMMARY for PR #$PR_NUMBER"
    echo "Repository: $OWNER/$REPO"
    echo ""

    local resolved_count=0
    local total_count=0

    # Process each comment and show resolution status
    echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment; do
        ((total_count++))
        COMMENT_ID=$(echo "$comment" | jq -r '.id')
        USER=$(echo "$comment" | jq -r '.user.login')
        FILE_PATH=$(echo "$comment" | jq -r '.path')
        LINE_NUMBER=$(echo "$comment" | jq -r '.line')
        BODY=$(echo "$comment" | jq -r '.body')

        # Get resolution if it exists
        RESOLUTION=$(get_resolution "$COMMENT_ID")

        echo "┌─────────────────────────────────────────────────────────────"
        echo "│ 💬 Comment ID: $COMMENT_ID ($USER)"
        echo "│ 📁 File: $FILE_PATH:$LINE_NUMBER"
        echo "├─────────────────────────────────────────────────────────────"

        # Show comment (truncated)
        COMMENT_PREVIEW=$(echo "$BODY" | head -2 | tr '\n' ' ' | cut -c1-60)
        echo "│ 🤖 Comment: $COMMENT_PREVIEW..."
        echo "│"

        if [[ -n "$RESOLUTION" ]]; then
            ((resolved_count++))
            echo "│ ✅ RESOLVED:"
            echo "$RESOLUTION" | grep -E "(resolution_action|reasoning|additional_notes|commit_hash)" | while IFS= read -r line; do
                if [[ "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*\"(.*)\"$ ]]; then
                    KEY="${BASH_REMATCH[1]}"
                    VALUE="${BASH_REMATCH[2]}"
                    case "$KEY" in
                        "resolution_action") echo "│   Action: $VALUE" ;;
                        "reasoning") echo "│   Reason: $VALUE" ;;
                        "additional_notes") [[ -n "$VALUE" ]] && echo "│   Notes: $VALUE" ;;
                        "commit_hash") [[ -n "$VALUE" ]] && echo "│   Commit: $VALUE" ;;
                    esac
                fi
            done
        else
            echo "│ ❌ NO RESOLUTION"
            echo "│   Run: ./scripts/check_pr_inline_comments.sh --annotate $PR_NUMBER"
        fi
        echo "└─────────────────────────────────────────────────────────────"
        echo ""
    done

    echo "📊 SUMMARY: $resolved_count/$total_count comments resolved ($(( resolved_count * 100 / total_count ))%)"
}

export_learning_patterns() {
    echo "📚 LEARNING EXPORT for PR #$PR_NUMBER"
    echo "Generating documentation from resolution patterns..."
    echo ""

    if [[ ! -f "$RESOLUTION_FILE" ]]; then
        echo "❌ No resolutions found for PR #$PR_NUMBER"
        echo "Run: ./scripts/check_pr_inline_comments.sh --annotate $PR_NUMBER"
        exit 1
    fi

    local export_file="docs/learning/pr-${PR_NUMBER}-lessons.md"
    mkdir -p "docs/learning"

    cat > "$export_file" << EOF
# PR #$PR_NUMBER Learning Summary

**Generated**: $(date -Iseconds)
**Repository**: $OWNER/$REPO
**Source**: DevOnboarder PR Comments Resolution Tracking

## Copilot Suggestions & Resolutions

EOF

    # Extract learning patterns
    local copilot_suggestions=0
    local applied_fixes=0

    echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment; do
        COMMENT_ID=$(echo "$comment" | jq -r '.id')
        USER=$(echo "$comment" | jq -r '.user.login')
        FILE_PATH=$(echo "$comment" | jq -r '.path')
        BODY=$(echo "$comment" | jq -r '.body')

        if [[ "$USER" == "github-copilot"* ]]; then
            ((copilot_suggestions++))
        fi

        RESOLUTION=$(get_resolution "$COMMENT_ID")
        if [[ -n "$RESOLUTION" ]]; then
            ((applied_fixes++))

            cat >> "$export_file" << EOF
### $FILE_PATH

**Copilot Suggestion:**
\`\`\`
$BODY
\`\`\`

**Resolution:**
EOF
            echo "$RESOLUTION" | grep -E "(resolution_action|reasoning)" | while IFS= read -r line; do
                if [[ "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*\"(.*)\"$ ]]; then
                    KEY="${BASH_REMATCH[1]}"
                    VALUE="${BASH_REMATCH[2]}"
                    case "$KEY" in
                        "resolution_action") echo "- **Action**: $VALUE" >> "$export_file" ;;
                        "reasoning") echo "- **Reasoning**: $VALUE" >> "$export_file" ;;
                    esac
                fi
            done
            echo "" >> "$export_file"
        fi
    done

    cat >> "$export_file" << EOF

## Metrics

- **Total Comments**: $(echo "$FILTERED_COMMENTS" | jq length)
- **Copilot Suggestions**: $copilot_suggestions
- **Applied Fixes**: $applied_fixes
- **Resolution Rate**: $(( applied_fixes * 100 / copilot_suggestions ))%

## Key Learnings

EOF

    echo "✅ Learning export created: $export_file"
    echo "📊 Metrics added to export"
    echo "🎯 Ready for documentation integration"
}

verify_resolutions() {
    echo "🔍 RESOLUTION VERIFICATION for PR #$PR_NUMBER"
    echo ""

    local unresolved_count=0
    local total_count=0

    echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment; do
        ((total_count++))
        COMMENT_ID=$(echo "$comment" | jq -r '.id')
        USER=$(echo "$comment" | jq -r '.user.login')

        RESOLUTION=$(get_resolution "$COMMENT_ID")
        if [[ -z "$RESOLUTION" ]]; then
            ((unresolved_count++))
            echo "❌ Unresolved: Comment $COMMENT_ID from $USER"
        fi
    done

    if [[ "$unresolved_count" -eq 0 ]]; then
        echo "✅ All comments have resolutions!"
        exit 0
    else
        echo "⚠️  $unresolved_count/$total_count comments need resolutions"
        echo "Run: ./scripts/check_pr_inline_comments.sh --annotate $PR_NUMBER"
        exit 1
    fi
}
