---
agent: ci-monitor
purpose: Automated real-time CI status monitoring and reporting for all PRs
trigger: on_pull_request, on_workflow_run, manual
environment: CI
output: .codex/logs/ci-monitor.log
permissions:
    - repo:read
    - actions:read
    - issues:write
    - pull_requests:write
---

# CI Monitor Agent

## Overview

The CI Monitor Agent provides automated, real-time CI status monitoring and structured reporting for all pull requests. It eliminates the need for manual CI triage by automatically classifying failures, generating actionable reports, and escalating issues based on predefined criteria.

## Core Behaviors

### 1. Pipeline Status Monitoring

```yaml
monitoring_triggers:
  - pull_request.opened
  - pull_request.synchronize
  - workflow_run.completed
  - schedule: "*/5 * * * *"  # Every 5 minutes for stuck pipelines
```

### 2. Failure Classification Engine

**Infrastructure/Process Failures:**

- npm ci failures (missing package.json, dependency resolution)
- Virtual environment context issues
- Docker build/network failures
- Authentication/permission errors
- Tool installation failures (Vale, GitHub CLI, etc.)

**Code/Logic Failures:**

- Test failures (pytest, jest, vitest)
- Linting violations (ruff, eslint, black)
- Type checking errors (mypy, TypeScript)
- Security audit failures (bandit, npm audit)
- Coverage threshold violations

**Policy/Compliance Failures:**

- Potato Policy violations
- Permission validation failures
- Documentation quality failures
- Commit message format violations

### 3. Automated Status Reports

**Real-time PR Status Comments:**

```markdown
## ðŸ” CI Status Report - PR #{{pr_number}}

**Last Updated:** {{timestamp}}
**Pipeline Status:** {{overall_status}}

### âœ… Completed Successfully
{{#successful_checks}}
- **{{name}}**: {{conclusion}} ({{duration}})
{{/successful_checks}}

### ðŸ”„ In Progress
{{#in_progress_checks}}
- **{{name}}**: {{status}} (started {{started_at}})
{{/in_progress_checks}}

### âŒ Failed
{{#failed_checks}}
- **{{name}}**: {{conclusion}}
  - **Classification:** {{failure_type}}
  - **Action Required:** {{recommended_action}}
  - **Details:** [View Log]({{details_url}})
{{/failed_checks}}

### ðŸ“Š Key Metrics
- **Total Duration:** {{total_duration}}
- **Success Rate:** {{success_percentage}}%
- **Infrastructure Issues:** {{infra_failure_count}}
- **Code Issues:** {{code_failure_count}}

### ðŸŽ¯ Next Steps
{{#recommendations}}
- {{action}}
{{/recommendations}}

---
*Generated by CI Monitor Agent at {{timestamp}}*
```

### 4. Escalation Rules

**Auto-Escalation Criteria:**

- Pipeline stuck for >30 minutes
- >3 consecutive infrastructure failures
- Security policy violations
- Coverage drops below threshold
- New failure patterns detected

**Notification Channels:**

- GitHub PR comments (always)
- Issue creation for persistent failures
- Slack/Discord integration (configurable)
- Email alerts for critical failures

## Implementation Framework

### Agent Configuration

```yaml
# .codex/agents/ci-monitor.yaml
ci_monitor:
  enabled: true
  update_frequency: 300  # 5 minutes
  failure_classification:
    timeout_threshold: 1800  # 30 minutes
    retry_attempts: 3
  notifications:
    github_comments: true
    issue_creation: true
    slack_webhook: "${SLACK_CI_WEBHOOK}"
  escalation_rules:
    stuck_pipeline_threshold: 1800
    consecutive_failure_threshold: 3
    critical_failure_immediate: true
```

### Core Functions

```python
# CI Monitor Agent Core Logic
class CIMonitorAgent:
    def __init__(self, config):
        self.config = config
        self.gh_client = GitHubClient()
        self.failure_classifier = FailureClassifier()

    async def monitor_pr_pipeline(self, pr_number: int):
        """Monitor all CI checks for a specific PR"""
        status_data = await self.gh_client.get_pr_status(pr_number)

        # Classify each check
        classified_checks = []
        for check in status_data['checks']:
            classification = self.failure_classifier.classify(check)
            classified_checks.append({
                **check,
                'classification': classification,
                'recommended_action': self.get_recommended_action(classification)
            })

        # Generate status report
        report = self.generate_status_report(pr_number, classified_checks)

        # Update PR comment
        await self.update_pr_status_comment(pr_number, report)

        # Check escalation rules
        if self.should_escalate(classified_checks):
            await self.escalate_issue(pr_number, classified_checks)

    def classify_failure(self, check_data):
        """Classify failure type based on logs and patterns"""
        if 'npm ci' in check_data['output'] and 'ENOENT' in check_data['output']:
            return 'infrastructure_npm_missing_package_json'
        elif 'ModuleNotFoundError' in check_data['output']:
            return 'infrastructure_python_missing_deps'
        elif 'test failed' in check_data['output']:
            return 'code_test_failure'
        elif 'coverage' in check_data['output'] and 'below' in check_data['output']:
            return 'code_coverage_violation'
        # ... additional classification logic

    def get_recommended_action(self, classification):
        """Get actionable recommendation based on failure type"""
        actions = {
            'infrastructure_npm_missing_package_json':
                'Remove npm ci step from root or move to service directory',
            'infrastructure_python_missing_deps':
                'Activate virtual environment before Python commands',
            'code_test_failure':
                'Review test logs and fix failing tests',
            'code_coverage_violation':
                'Add tests to meet coverage threshold'
        }
        return actions.get(classification, 'Manual investigation required')
```

### Integration Points

**GitHub Actions Integration:**

```yaml
# .github/workflows/ci-monitor.yml
name: CI Monitor
on:
  pull_request:
    types: [opened, synchronize]
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  schedule:
    - cron: "*/5 * * * *"

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run CI Monitor Agent
        run: python .codex/agents/ci_monitor.py
        env:
          GH_TOKEN: ${{ secrets.CI_ISSUE_AUTOMATION_TOKEN }}
```

## Audit Trail & Logging

### Event Logging Format

```json
{
  "timestamp": "2025-07-28T22:30:00Z",
  "agent": "ci-monitor",
  "event_type": "status_update",
  "pr_number": 970,
  "pipeline_id": "16581415930",
  "checks_analyzed": 18,
  "classifications": {
    "infrastructure_failures": 0,
    "code_failures": 2,
    "policy_failures": 0
  },
  "actions_taken": [
    "updated_pr_comment",
    "escalated_to_issue_1234"
  ],
  "execution_time_ms": 1247
}
```

### Metrics Dashboard Data

- Pipeline success rates over time
- Failure classification trends
- MTTR (Mean Time To Resolution) by failure type
- Infrastructure vs. code failure ratios
- Developer velocity impact metrics

## Success Metrics

**Operational Excellence KPIs:**

- 95%+ accurate failure classification
- <5 minute status update latency
- 80% reduction in manual CI triage time
- 90% developer satisfaction with CI clarity
- Zero missed critical security failures

**Quality Assurance:**

- All status updates include actionable next steps
- Historical trend analysis for pattern recognition
- Automated documentation of recurring issues
- Integration with existing issue tracking systems

## Future Enhancements

1. **Machine Learning Integration**
   - Pattern recognition for new failure types
   - Predictive failure detection
   - Automated fix suggestions

2. **Cross-Repository Intelligence**
   - Learn from failures across all repositories
   - Share classification improvements
   - Organization-wide CI health dashboard

3. **Developer Experience Optimization**
   - Personalized failure summaries
   - Contextual help based on developer history
   - Integration with IDE and development tools

---

**Agent Validation:** This agent follows the DevOnboarder Enhanced Potato Policy and includes comprehensive audit logging for all operations.
